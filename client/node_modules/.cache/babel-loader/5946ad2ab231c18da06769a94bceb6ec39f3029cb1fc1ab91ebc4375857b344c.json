{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { canUseWeakMap, compact, isNonEmptyArray, maybeDeepFreeze } from \"../../utilities/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useQuery } from '@apollo/client';\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: 'english' },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery(query, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n  return wrapHook(\"useQuery\", _useQuery, useApolloClient(options && options.client))(query, options);\n}\nfunction _useQuery(query, options) {\n  return useInternalState(useApolloClient(options.client), query).useQuery(options);\n}\nexport function useInternalState(client, query) {\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate or the\n  // uSES notification callback are the only way we trigger React component updates.\n  var forceUpdateState = React.useReducer(function (tick) {\n    return tick + 1;\n  }, 0)[1];\n  function createInternalState(previous) {\n    return Object.assign(new InternalState(client, query, previous), {\n      forceUpdateState: forceUpdateState\n    });\n  }\n  var _a = React.useState(createInternalState),\n    state = _a[0],\n    updateState = _a[1];\n  if (client !== state.client || query !== state.query) {\n    // If the client or query have changed, we need to create a new InternalState.\n    // This will trigger a re-render with the new state, but it will also continue\n    // to run the current render function to completion.\n    // Since we sometimes trigger some side-effects in the render function, we\n    // re-assign `state` to the new state to ensure that those side-effects are\n    // triggered with the new state.\n    updateState(state = createInternalState(state));\n  }\n  return state;\n}\nvar InternalState = /** @class */function () {\n  function InternalState(client, query, previous) {\n    var _this = this;\n    this.client = client;\n    this.query = query;\n    /**\n     * Will be overwritten by the `useSyncExternalStore` \"force update\" method\n     * whenever it is available and reset to `forceUpdateState` when it isn't.\n     */\n    this.forceUpdate = function () {\n      return _this.forceUpdateState();\n    };\n    this.ssrDisabledResult = maybeDeepFreeze({\n      loading: true,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.loading\n    });\n    this.skipStandbyResult = maybeDeepFreeze({\n      loading: false,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.ready\n    });\n    // This cache allows the referential stability of this.result (as returned by\n    // getCurrentResult) to translate into referential stability of the resulting\n    // QueryResult object returned by toQueryResult.\n    this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();\n    verifyDocumentType(query, DocumentType.Query);\n    // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n    var previousResult = previous && previous.result;\n    var previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n  /**\n   * Forces an update using local component state.\n   * As this is not batched with `useSyncExternalStore` updates,\n   * this is only used as a fallback if the `useSyncExternalStore` \"force update\"\n   * method is not registered at the moment.\n   * See https://github.com/facebook/react/issues/25191\n   *  */\n  InternalState.prototype.forceUpdateState = function () {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    globalThis.__DEV__ !== false && invariant.warn(51);\n  };\n  InternalState.prototype.executeQuery = function (options) {\n    var _this = this;\n    var _a;\n    if (options.query) {\n      Object.assign(this, {\n        query: options.query\n      });\n    }\n    this.watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);\n    var concast = this.observable.reobserveAsConcast(this.getObsQueryOptions());\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n    this.result = void 0;\n    this.forceUpdate();\n    return new Promise(function (resolve) {\n      var result;\n      // Subscribe to the concast independently of the ObservableQuery in case\n      // the component gets unmounted before the promise resolves. This prevents\n      // the concast from terminating early and resolving with `undefined` when\n      // there are no more subscribers for the concast.\n      concast.subscribe({\n        next: function (value) {\n          result = value;\n        },\n        error: function () {\n          resolve(_this.toQueryResult(_this.observable.getCurrentResult()));\n        },\n        complete: function () {\n          resolve(_this.toQueryResult(result));\n        }\n      });\n    });\n  };\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  InternalState.prototype.useQuery = function (options) {\n    var _this = this;\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    this.renderPromises = React.useContext(getApolloContext()).renderPromises;\n    this.useOptions(options);\n    var obsQuery = this.useObservableQuery();\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    var result = useSyncExternalStore(\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useCallback(function (handleStoreChange) {\n      if (_this.renderPromises) {\n        return function () {};\n      }\n      _this.forceUpdate = handleStoreChange;\n      var onNext = function () {\n        var previousResult = _this.result;\n        // We use `getCurrentResult()` instead of the onNext argument because\n        // the values differ slightly. Specifically, loading results will have\n        // an empty object for data instead of `undefined` for some reason.\n        var result = obsQuery.getCurrentResult();\n        // Make sure we're not attempting to re-render similar results\n        if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && equal(previousResult.data, result.data)) {\n          return;\n        }\n        _this.setResult(result);\n      };\n      var onError = function (error) {\n        subscription.unsubscribe();\n        subscription = obsQuery.resubscribeAfterError(onNext, onError);\n        if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n          // The error is not a GraphQL error\n          throw error;\n        }\n        var previousResult = _this.result;\n        if (!previousResult || previousResult && previousResult.loading || !equal(error, previousResult.error)) {\n          _this.setResult({\n            data: previousResult && previousResult.data,\n            error: error,\n            loading: false,\n            networkStatus: NetworkStatus.error\n          });\n        }\n      };\n      var subscription = obsQuery.subscribe(onNext, onError);\n      // Do the \"unsubscribe\" with a short delay.\n      // This way, an existing subscription can be reused without an additional\n      // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n      // happen in very fast succession.\n      return function () {\n        setTimeout(function () {\n          return subscription.unsubscribe();\n        });\n        _this.forceUpdate = function () {\n          return _this.forceUpdateState();\n        };\n      };\n    }, [\n    // We memoize the subscribe function using useCallback and the following\n    // dependency keys, because the subscribe function reference is all that\n    // useSyncExternalStore uses internally as a dependency key for the\n    // useEffect ultimately responsible for the subscription, so we are\n    // effectively passing this dependency array to that useEffect buried\n    // inside useSyncExternalStore, as desired.\n    obsQuery,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    this.renderPromises,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    this.client.disableNetworkFetches]), function () {\n      return _this.getCurrentResult();\n    }, function () {\n      return _this.getCurrentResult();\n    });\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n    return this.toQueryResult(result);\n  };\n  InternalState.prototype.useOptions = function (options) {\n    var _a;\n    var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    var currentWatchQueryOptions = this.watchQueryOptions;\n    if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n      if (currentWatchQueryOptions && this.observable) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions());\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n        this.result = void 0;\n      }\n    }\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n    if ((this.renderPromises || this.client.disableNetworkFetches) && this.queryHookOptions.ssr === false && !this.queryHookOptions.skip) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (this.queryHookOptions.skip || this.watchQueryOptions.fetchPolicy === \"standby\") {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (this.result === this.ssrDisabledResult || this.result === this.skipStandbyResult) {\n      this.result = void 0;\n    }\n  };\n  InternalState.prototype.getObsQueryOptions = function () {\n    var toMerge = [];\n    var globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(compact(this.observable && this.observable.options, this.watchQueryOptions));\n    return toMerge.reduce(mergeOptions);\n  };\n  // A function to massage options before passing them to ObservableQuery.\n  InternalState.prototype.createWatchQueryOptions = function (_a) {\n    var _b;\n    if (_a === void 0) {\n      _a = {};\n    }\n    var skip = _a.skip,\n      ssr = _a.ssr,\n      onCompleted = _a.onCompleted,\n      onError = _a.onError,\n      defaultOptions = _a.defaultOptions,\n      // The above options are useQuery-specific, so this ...otherOptions spread\n      // makes otherOptions almost a WatchQueryOptions object, except for the\n      // query property that we add below.\n      otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]);\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    var watchQueryOptions = Object.assign(otherOptions, {\n      query: this.query\n    });\n    if (this.renderPromises && (watchQueryOptions.fetchPolicy === \"network-only\" || watchQueryOptions.fetchPolicy === \"cache-and-network\")) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = \"cache-first\";\n    }\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {};\n    }\n    if (skip) {\n      var _c = watchQueryOptions.fetchPolicy,\n        fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c,\n        _d = watchQueryOptions.initialFetchPolicy,\n        initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy: initialFetchPolicy,\n        fetchPolicy: \"standby\"\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy = ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) || this.getDefaultFetchPolicy();\n    }\n    return watchQueryOptions;\n  };\n  InternalState.prototype.getDefaultFetchPolicy = function () {\n    var _a, _b;\n    return ((_a = this.queryHookOptions.defaultOptions) === null || _a === void 0 ? void 0 : _a.fetchPolicy) || ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || \"cache-first\";\n  };\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  InternalState.prototype.onCompleted = function (data) {};\n  InternalState.prototype.onError = function (error) {};\n  InternalState.prototype.useObservableQuery = function () {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    var obsQuery = this.observable = this.renderPromises && this.renderPromises.getSSRObservable(this.watchQueryOptions) || this.observable ||\n    // Reuse this.observable if possible (and not SSR)\n    this.client.watchQuery(this.getObsQueryOptions());\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    this.obsQueryFields = React.useMemo(function () {\n      return {\n        refetch: obsQuery.refetch.bind(obsQuery),\n        reobserve: obsQuery.reobserve.bind(obsQuery),\n        fetchMore: obsQuery.fetchMore.bind(obsQuery),\n        updateQuery: obsQuery.updateQuery.bind(obsQuery),\n        startPolling: obsQuery.startPolling.bind(obsQuery),\n        stopPolling: obsQuery.stopPolling.bind(obsQuery),\n        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)\n      };\n    }, [obsQuery]);\n    var ssrAllowed = !(this.queryHookOptions.ssr === false || this.queryHookOptions.skip);\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n    return obsQuery;\n  };\n  InternalState.prototype.setResult = function (nextResult) {\n    var previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult, previousResult);\n  };\n  InternalState.prototype.handleErrorOrCompleted = function (result, previousResult) {\n    var _this = this;\n    if (!result.loading) {\n      var error_1 = this.toApolloError(result);\n      // wait a tick in case we are in the middle of rendering a component\n      Promise.resolve().then(function () {\n        if (error_1) {\n          _this.onError(error_1);\n        } else if (result.data && (previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus) !== result.networkStatus && result.networkStatus === NetworkStatus.ready) {\n          _this.onCompleted(result.data);\n        }\n      }).catch(function (error) {\n        globalThis.__DEV__ !== false && invariant.warn(error);\n      });\n    }\n  };\n  InternalState.prototype.toApolloError = function (result) {\n    return isNonEmptyArray(result.errors) ? new ApolloError({\n      graphQLErrors: result.errors\n    }) : result.error;\n  };\n  InternalState.prototype.getCurrentResult = function () {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());\n    }\n    return this.result;\n  };\n  InternalState.prototype.toQueryResult = function (result) {\n    var queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n    var data = result.data,\n      partial = result.partial,\n      resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n    this.toQueryResultCache.set(result, queryResult = __assign(__assign(__assign({\n      data: data\n    }, resultWithoutPartial), this.obsQueryFields), {\n      client: this.client,\n      observable: this.observable,\n      variables: this.observable.variables,\n      called: !this.queryHookOptions.skip,\n      previousData: this.previousData\n    }));\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({\n        graphQLErrors: result.errors\n      });\n    }\n    return queryResult;\n  };\n  InternalState.prototype.unsafeHandlePartialRefetch = function (result) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (result.partial && this.queryHookOptions.partialRefetch && !result.loading && (!result.data || Object.keys(result.data).length === 0) && this.observable.options.fetchPolicy !== \"cache-only\") {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch\n      });\n      this.observable.refetch();\n    }\n  };\n  return InternalState;\n}();","map":{"version":3,"names":["invariant","React","useSyncExternalStore","equal","mergeOptions","getApolloContext","ApolloError","NetworkStatus","DocumentType","verifyDocumentType","useApolloClient","canUseWeakMap","compact","isNonEmptyArray","maybeDeepFreeze","wrapHook","hasOwnProperty","Object","prototype","useQuery","query","options","create","_useQuery","client","useInternalState","forceUpdateState","useReducer","tick","createInternalState","previous","assign","InternalState","_a","useState","state","updateState","_this","forceUpdate","ssrDisabledResult","loading","data","error","networkStatus","skipStandbyResult","ready","toQueryResultCache","WeakMap","Map","Query","previousResult","result","previousData","globalThis","__DEV__","warn","executeQuery","watchQueryOptions","createWatchQueryOptions","queryHookOptions","concast","observable","reobserveAsConcast","getObsQueryOptions","Promise","resolve","subscribe","next","value","toQueryResult","getCurrentResult","complete","renderPromises","useContext","useOptions","obsQuery","useObservableQuery","useCallback","handleStoreChange","onNext","setResult","onError","subscription","unsubscribe","resubscribeAfterError","call","setTimeout","disableNetworkFetches","unsafeHandlePartialRefetch","currentWatchQueryOptions","reobserve","onCompleted","ssr","skip","fetchPolicy","toMerge","globalDefaults","defaultOptions","watchQuery","push","reduce","otherOptions","__rest","variables","_c","getDefaultFetchPolicy","_d","initialFetchPolicy","_b","getSSRObservable","obsQueryFields","useMemo","refetch","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","ssrAllowed","registerSSRObservable","addObservableQueryPromise","nextResult","handleErrorOrCompleted","error_1","toApolloError","then","catch","errors","graphQLErrors","queryResult","get","partial","resultWithoutPartial","set","__assign","called","partialRefetch","keys","length"],"sources":["/home/suhaibinsari/Documents/Github/NodeJs/graphQl/client/node_modules/@apollo/src/react/hooks/useQuery.ts"],"sourcesContent":["import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"rehackt\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\n\nimport type {\n  OperationVariables,\n  WatchQueryFetchPolicy,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type { ApolloContextValue } from \"../context/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport type {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport {\n  canUseWeakMap,\n  compact,\n  isNonEmptyArray,\n  maybeDeepFreeze,\n} from \"../../utilities/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\n\nconst {\n  prototype: { hasOwnProperty },\n} = Object;\n\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useQuery } from '@apollo/client';\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: 'english' },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>\n  > = Object.create(null)\n): QueryResult<TData, TVariables> {\n  return wrapHook(\n    \"useQuery\",\n    _useQuery,\n    useApolloClient(options && options.client)\n  )(query, options);\n}\n\nfunction _useQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n) {\n  return useInternalState(useApolloClient(options.client), query).useQuery(\n    options\n  );\n}\n\nexport function useInternalState<TData, TVariables extends OperationVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>\n): InternalState<TData, TVariables> {\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate or the\n  // uSES notification callback are the only way we trigger React component updates.\n  const forceUpdateState = React.useReducer((tick) => tick + 1, 0)[1];\n\n  function createInternalState(previous?: InternalState<TData, TVariables>) {\n    return Object.assign(new InternalState(client, query, previous), {\n      forceUpdateState,\n    });\n  }\n\n  let [state, updateState] = React.useState(createInternalState);\n\n  if (client !== state.client || query !== state.query) {\n    // If the client or query have changed, we need to create a new InternalState.\n    // This will trigger a re-render with the new state, but it will also continue\n    // to run the current render function to completion.\n    // Since we sometimes trigger some side-effects in the render function, we\n    // re-assign `state` to the new state to ensure that those side-effects are\n    // triggered with the new state.\n    updateState((state = createInternalState(state)));\n  }\n\n  return state;\n}\n\nclass InternalState<TData, TVariables extends OperationVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    previous?: InternalState<TData, TVariables>\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n\n    // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n    const previousResult = previous && previous.result;\n    const previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n\n  /**\n   * Forces an update using local component state.\n   * As this is not batched with `useSyncExternalStore` updates,\n   * this is only used as a fallback if the `useSyncExternalStore` \"force update\"\n   * method is not registered at the moment.\n   * See https://github.com/facebook/react/issues/25191\n   *  */\n  forceUpdateState() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    invariant.warn(\n      \"Calling default no-op implementation of InternalState#forceUpdate\"\n    );\n  }\n\n  /**\n   * Will be overwritten by the `useSyncExternalStore` \"force update\" method\n   * whenever it is available and reset to `forceUpdateState` when it isn't.\n   */\n  forceUpdate = () => this.forceUpdateState();\n\n  executeQuery(\n    options: QueryHookOptions<TData, TVariables> & {\n      query?: DocumentNode;\n    }\n  ) {\n    if (options.query) {\n      Object.assign(this, { query: options.query });\n    }\n\n    this.watchQueryOptions = this.createWatchQueryOptions(\n      (this.queryHookOptions = options)\n    );\n\n    const concast = this.observable.reobserveAsConcast(\n      this.getObsQueryOptions()\n    );\n\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    this.previousData = this.result?.data || this.previousData;\n    this.result = void 0;\n    this.forceUpdate();\n\n    return new Promise<QueryResult<TData, TVariables>>((resolve) => {\n      let result: ApolloQueryResult<TData>;\n\n      // Subscribe to the concast independently of the ObservableQuery in case\n      // the component gets unmounted before the promise resolves. This prevents\n      // the concast from terminating early and resolving with `undefined` when\n      // there are no more subscribers for the concast.\n      concast.subscribe({\n        next: (value) => {\n          result = value;\n        },\n        error: () => {\n          resolve(this.toQueryResult(this.observable.getCurrentResult()));\n        },\n        complete: () => {\n          resolve(this.toQueryResult(result));\n        },\n      });\n    });\n  }\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    this.renderPromises = React.useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const result = useSyncExternalStore(\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      React.useCallback(\n        (handleStoreChange) => {\n          if (this.renderPromises) {\n            return () => {};\n          }\n\n          this.forceUpdate = handleStoreChange;\n\n          const onNext = () => {\n            const previousResult = this.result;\n            // We use `getCurrentResult()` instead of the onNext argument because\n            // the values differ slightly. Specifically, loading results will have\n            // an empty object for data instead of `undefined` for some reason.\n            const result = obsQuery.getCurrentResult();\n            // Make sure we're not attempting to re-render similar results\n            if (\n              previousResult &&\n              previousResult.loading === result.loading &&\n              previousResult.networkStatus === result.networkStatus &&\n              equal(previousResult.data, result.data)\n            ) {\n              return;\n            }\n\n            this.setResult(result);\n          };\n\n          const onError = (error: Error) => {\n            subscription.unsubscribe();\n            subscription = obsQuery.resubscribeAfterError(onNext, onError);\n\n            if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n              // The error is not a GraphQL error\n              throw error;\n            }\n\n            const previousResult = this.result;\n            if (\n              !previousResult ||\n              (previousResult && previousResult.loading) ||\n              !equal(error, previousResult.error)\n            ) {\n              this.setResult({\n                data: (previousResult && previousResult.data) as TData,\n                error: error as ApolloError,\n                loading: false,\n                networkStatus: NetworkStatus.error,\n              });\n            }\n          };\n\n          let subscription = obsQuery.subscribe(onNext, onError);\n\n          // Do the \"unsubscribe\" with a short delay.\n          // This way, an existing subscription can be reused without an additional\n          // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n          // happen in very fast succession.\n          return () => {\n            setTimeout(() => subscription.unsubscribe());\n            this.forceUpdate = () => this.forceUpdateState();\n          };\n        },\n        [\n          // We memoize the subscribe function using useCallback and the following\n          // dependency keys, because the subscribe function reference is all that\n          // useSyncExternalStore uses internally as a dependency key for the\n          // useEffect ultimately responsible for the subscription, so we are\n          // effectively passing this dependency array to that useEffect buried\n          // inside useSyncExternalStore, as desired.\n          obsQuery,\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          this.renderPromises,\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          this.client.disableNetworkFetches,\n        ]\n      ),\n\n      () => this.getCurrentResult(),\n      () => this.getCurrentResult()\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    return this.toQueryResult(result);\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions!: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions!: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(options: QueryHookOptions<TData, TVariables>) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      (this.queryHookOptions = options)\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n\n    if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions());\n\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted =\n      options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false &&\n      !this.queryHookOptions.skip\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === \"standby\"\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private getObsQueryOptions(): WatchQueryOptions<TVariables, TData> {\n    const toMerge: Array<Partial<WatchQueryOptions<TVariables, TData>>> = [];\n\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(\n      compact(\n        this.observable && this.observable.options,\n        this.watchQueryOptions\n      )\n    );\n\n    return toMerge.reduce(mergeOptions) as WatchQueryOptions<TVariables, TData>;\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<\n    TVariables,\n    TData\n  > {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(otherOptions, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (watchQueryOptions.fetchPolicy === \"network-only\" ||\n        watchQueryOptions.fetchPolicy === \"cache-and-network\")\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = \"cache-first\";\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    if (skip) {\n      const {\n        fetchPolicy = this.getDefaultFetchPolicy(),\n        initialFetchPolicy = fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: \"standby\",\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy =\n        this.observable?.options.initialFetchPolicy ||\n        this.getDefaultFetchPolicy();\n    }\n\n    return watchQueryOptions;\n  }\n\n  getDefaultFetchPolicy(): WatchQueryFetchPolicy {\n    return (\n      this.queryHookOptions.defaultOptions?.fetchPolicy ||\n      this.client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\"\n    );\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable!: ObservableQuery<TData, TVariables>;\n  public obsQueryFields!: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = (this.observable =\n      (this.renderPromises &&\n        this.renderPromises.getSSRObservable(this.watchQueryOptions)) ||\n      this.observable || // Reuse this.observable if possible (and not SSR)\n      this.client.watchQuery(this.getObsQueryOptions()));\n\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    this.obsQueryFields = React.useMemo(\n      () => ({\n        refetch: obsQuery.refetch.bind(obsQuery),\n        reobserve: obsQuery.reobserve.bind(obsQuery),\n        fetchMore: obsQuery.fetchMore.bind(obsQuery),\n        updateQuery: obsQuery.updateQuery.bind(obsQuery),\n        startPolling: obsQuery.startPolling.bind(obsQuery),\n        stopPolling: obsQuery.stopPolling.bind(obsQuery),\n        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n      }),\n      [obsQuery]\n    );\n\n    const ssrAllowed = !(\n      this.queryHookOptions.ssr === false || this.queryHookOptions.skip\n    );\n\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult, previousResult);\n  }\n\n  private handleErrorOrCompleted(\n    result: ApolloQueryResult<TData>,\n    previousResult?: ApolloQueryResult<TData>\n  ) {\n    if (!result.loading) {\n      const error = this.toApolloError(result);\n\n      // wait a tick in case we are in the middle of rendering a component\n      Promise.resolve()\n        .then(() => {\n          if (error) {\n            this.onError(error);\n          } else if (\n            result.data &&\n            previousResult?.networkStatus !== result.networkStatus &&\n            result.networkStatus === NetworkStatus.ready\n          ) {\n            this.onCompleted(result.data);\n          }\n        })\n        .catch((error) => {\n          invariant.warn(error);\n        });\n    }\n  }\n\n  private toApolloError(\n    result: ApolloQueryResult<TData>\n  ): ApolloError | undefined {\n    return isNonEmptyArray(result.errors) ?\n        new ApolloError({ graphQLErrors: result.errors })\n      : result.error;\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        (this.result = this.observable.getCurrentResult())\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(\n      result,\n      (queryResult = {\n        data, // Ensure always defined, even if result.data is missing.\n        ...resultWithoutPartial,\n        ...this.obsQueryFields,\n        client: this.client,\n        observable: this.observable,\n        variables: this.observable.variables,\n        called: !this.queryHookOptions.skip,\n        previousData: this.previousData,\n      })\n    );\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== \"cache-only\"\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}